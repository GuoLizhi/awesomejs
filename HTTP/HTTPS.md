HTTPS的安全基础是SSL

HTTPS原理的4个重要基础`对称加密 + 非对称加密 + hash散列算法 + CA`

### 1. 对称加密

对称加密是指对于加解密都采用的是同一个秘钥，可以这样来表示

```
# 其中data表示需要加密的数据，sk表示加密秘钥，X表示加密的结果
# 加密过程
f(data, sk) = X
# 解密过程
f(X, sk) = data
```

整个过程使用同样的秘钥进行操作，但是这样存在一个问题，这个秘钥很容易被截获。因为对于黑客而言，它本身也是一个客户端，也可以拿到这个秘钥。一旦这个秘钥被拿到，那就表明了所有的用户的HTTP传输内容都可以被解析。而且也太不可能为每个用户设定一个单独的秘钥，这样从服务器的角度会增加大量的额外成本，比如秘钥存储，读取秘钥的IO操作等。

### 2. 非对称加密

非对称加密：存在着公钥和私钥。通过公钥加密的数据可以使用私钥来解密；同样使用私钥加密的数据也可以通过对应的公钥来解密。私钥存在于服务端，而公钥存在于客户端（服务端发送过去的）。

```
# 其中data表示需要加密的数据，sk表示秘钥，pk表示公钥，X表示加密的结果

# 私钥加密，公钥解密
f(data, sk) = X
f(X, pk) = data

# 公钥加密，私钥解密
f(data, pk) = X
f(X, sk) = data
```

客户端可服务端具体的交互步骤

```
1. client向server请求公钥
2. server向client发送公钥
3. 之后client向server通信，都会使用这个公钥来加密
4. server向client通信，都会使用私钥来加密
```

但是这种做法也是极不安全的，如果在第2步的时候，被黑客拦截，就会产生下面的交互步骤

```
1. client向server请求公钥
2. 被黑客拦截，此时黑客返回给client它自己的公钥，然后黑客它自己是可以获取到真实的公钥的
3. 之后的过程，client使用黑客的公钥加密，信息继续被黑客拦截，黑客用自己的私钥解密，窃取真实的数据
4. 黑客用真实的公钥加密真实的数据，然后发给server
5. 服务端接收到之后，用server的私钥解密之后，正常返回
6. 黑客用公钥解密，窃取到server返回的真实数据
7. 黑客用自己的私钥加密真实数据返回给client端
```

整个交互过程就完成了一次`中间人攻击`。其根本的原因就是客户端无法区分当前获取到的公钥是真实的还是黑客的。这就需要用到一个第三方的权威机构CA

### 3. CA认证

CA用来确保和client直接通信的是真实的server端，防止中间人攻击。它也有自己的私钥和公钥。公钥储存于服务端，私钥安装于客户端本地，无需通过网络通信来传输。CA的直接作用就是确保上面的步骤2的可靠性。CA会使用自己的私钥加密非对称加密的公钥，然后发送给client端。在client端通过CA的公钥进行解密，让client端获取到**真实的非对称加密公钥**。具体的交互步骤如下：

```
1. client->server: 请求支持的SSL版本，非对称加密算法，以及随机数1
2. server->client: 返回支持的SSL版本，非对称加密算法，以及随机数2，CA证书
3. client: 对证书进行认证，如果证书异常会在client端提示
4. client->server: 发送随机数3，并通过hash散列算法对1，2步中的所有数据进行加密生成XX，将这个XX也发送给server
5. server: 接收到XX，并用同样的hash散列算法对1,2步中的所有数据进行加密，看是否等于XX，如果等于XX表明没有被篡改过。然后通过随机数1,2,3,生成一个key
6. server->client: 发送通过hash散列算法对1,2,4中的数据加密生成YY
7. client: 也通过同样的hash散列算法对1,2,4中的数据加密生成YY'，看YY是否等于YY'，如果等于也会使用随机数1,2,3,生成一个key，这个key就是之后通信过程中，对称加密的秘钥。这个秘钥对于每一个用户来说都是唯一的
```

以上3步，就是基本的HTTPS原理

### 4. 为什么不会产生中间人攻击？

因为黑客最多只能拦截到服务端的公钥，但是client此时的数据是通过真实的公钥加密的，必须要有服务端的私钥才能解密。因此无法破解客户端的数据。并且最终对称加密的秘钥也没有在网络上传输，因此无法被截获。