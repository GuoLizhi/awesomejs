依赖收集解决的问题：当数据发生变化时，Vue知道去哪里通知那些使用到数据的地方也改变

依赖收集分为两个过程

1. 数据初始化流程
2. 依赖收集流程

在数据初始化的过程中，比如data的初始化，Vue会遍历data中的数据，使用Object.defineProperty来做数据劫持。当读取数据时会触发get操作，这个过程是依赖收集的过程，当更新数据时，会触发set操作，这个过程是通知依赖更新的过程

当页面解析模板生成render function, 渲染函数执行时，就会触发读取的操作

```js
// 渲染函数
// <div>{{name}}</div>
with(this) {
  return _c('div', {}, [name])
}
```

当上面的name被读取时，这里就会收集到渲染函数的watcher

```js
get() {
  if (Dep.target) {
    dep.addSub(Dep.target)
  }
}
```

- Dep.target 指向各种watcher，比如页面渲染函数watcher，watch的watcher
- Dep是一个构造函数，带有很多方法，其实例会包含一个subs数组，用于存储收集的各种依赖
- dep.addSub向subs中添加watcher

对象类型的数据如何收集依赖

具体流程：

- 遍历对象的每个属性，同样设置响应式
- 每个数据对象都会增加一个`__ob__`属性，这个属性上也会包含一份依赖（各种watcher）。

为什么需要这样再次存储依赖？因为原本的依赖是使用闭包的形式存储，其它地方是无法使用到的。为什么会在其它地方使用到？那是因为Vue重写了对象的set，del方法。这些新重写的方法内是无法获取到之前闭包内部依赖的

对于对象而言，set和del方法用来新增和删除key，并且都会通知依赖更新`target.__ob__.dep.notify()`

如果是数组，首先会遍历数组，如果数组的某一项是对象，则依然会走上面对象的流程，给每一个对象新增一个`__ob__`的属性。对于数组本身而言，也会新增一个`__ob__`的属性，用来存储当前的依赖。数组存储依赖的目的是为了重写数组原型上的方法，比如push, splice等等，重写的方法中也会有通知依赖更新的操作

通知依赖更新的大致流程

1. 修改属性值
2. 通知保存的依赖进行更新

通知依赖更新，实际上就是调用watcher上的update方法，而update方法实际上就是重新执行了之前保存的expOrFn。expOrFn就是用来计算最新值的更新函数。